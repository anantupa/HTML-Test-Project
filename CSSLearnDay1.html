<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/CSS" href="Project2_1.css" />
    <!--<style>
      p {
        color: blueviolet;
      }
    </style>-->
  </head>
  <body>
    <!--<pre style="color: red; font-size: large">paragraph 1</pre>
    <hr />
    <p>paragraph 2</p>
    <hr />
    <p>paragraph 3</p>-->
  
  <h1 id="h" class="Green">Heading</h1>
  <p>Paragraph 1</p>
  <p class="Green">Paragraph 2</p>
  <p id="asa">Paragraph 3</p>
  <p>Paragraph 4</p>
  <p class="Green">Paragraph 5</p>

  <div id="bg">
    Often, the best debugging technique is to print every method call and return
    <p>
      (or at least the most important ones). You probably want to print, for
      each method, what parameters it came in with, and what value it leaves
      with.
    </p>
    <p>For example, you could make the following sequence of moves:</p>
        <p>Now to the program. The main program will initialize the board, and call a recursive backtracking routine to attempt
           to solve the puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, 
           and the main program will have to print out the bad news.</p>
        <p>The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether
          we are at a leaf, which in this case means a position from which no further moves are possible. This isn't so easy.</p>
        <p>Each possible move will result in a new board position, and these new board positions are the children of the current
           board position. Hence to find the children of a node (that is, of a board position), we need only find the possible
            moves from that node. Remember that it is also highly desirable to find an ordering on these possible moves.</p>
        <p>Here it is time to stop and take thought. To make progress, we must analyze the game to some extent.
           Probably a number of approaches would work, and what follows is based on the way I worked it out. 
           If you were to program this puzzle, you might find a different but equally valid approach.</p>
        <p>First, notice that if a marble has a move, that move is unique: if it can move ahead one square, then
           it cannot jump. If it can jump, it cannot move ahead one square. This suggests that, to find the
          possible moves, we might assign numbers to the marbles, and check each marble in turn. When we have looked 
          at all the marbles, we have looked at all the possible moves. This would require having a table to keep track of
          where each marble is, or else somehow "marking" each marble with its number and searching the board each time
          to find the marble we want. Neither alternative is very attractive.</p>
        <p>Next, notice that for a given board position, each marble occupies a unique space. Hence, 
          instead of talking about moving a particular marble, we can talk about moving the marble in a particular space. 
          If a move is possible from a given space, then that must be the only move possible from that space, because if 
          the marble in that space has a move, it is unique. There is a slight complication because not every space contains a 
          marble, but at least the spaces (unlike the marbles) stay in one place.</p>
        <p>Now we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. 
          For each space, either zero or one moves is possible. With this understanding, we can write a boolean method 
          canMove(int[] board, int position) which determines whether a move is possible from the given position:</p>
    However, if you just print a long list of these, it's hard to match up
    method exits with their corresponding entries. Indenting to show the level
    of nesting can help.
      <pre> Entering solvable(A)
    |  |  Entering solvable(C)
    |  |  |  Entering solvable(null)
    |  |  |  solvable(null) returns false
    |  |  |  Entering solvable(null)
    |  |  |  solvable(null) returns false
    |  |  solvable(C) returns false
    |  |  Entering solvable(D)
    |  |  |  Entering solvable(null)
    |  |  |  solvable(null) returns false
    |  |  |  Entering solvable(null)
    |  |  |  solvable(null) returns false
    |  |  solvable(D) returns false
    |  solvable(A) returns false
    |  Entering solvable(B)
    |  |  Entering solvable(E)
    |  |  solvable(E) returns true
    |  solvable(B) returns true
    solvable(Root) returns true</pre>
    <p>The zeros in the above table indicate times too short to measure (less than 1 millisecond). 
  Why this huge difference? Either of these methods could have exponential growth. Eliminating a node automatically eliminates all
  of its descendents, and this will often prevent exponential growth. Conversely, by waiting to check until a leaf node is reached, 
  exponential growth is practically guaranteed. <b><i>If there is any way to eliminate children (reduce the set of choices), do so!</i></b></p>
<h3>Debugging techniques</h3>
<p>Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful,
  but sometimes we need to fall back on inserting print statements. There are some simple tricks to making effective use of
  print statements. These tricks can be applied to any program, but are especially useful when you are trying to debug recursive
  routines.
</p>
<p> <b>Trick #1: Indent when you print method entries and exits.</b> Often, the best debugging technique is to print every method
  call and return (or at least the most important ones). You probably want to print, for each method, what parameters it came in 
  with, and what value it leaves with. However, if you just print a long list of these, it's hard to match up method exits with their
  corresponding entries. Indenting to show the level of nesting can help.
</p>
<p><b>Trick #2: Use specialized print methods for debugging.</b> Don't clutter up your actual code more than you must. Also,
  remember that code inserted for debugging purposes can itself contain bugs, or (in the worst case) can affect the results,
  so be very careful with it.
</p>

    </body>
  </div>
</html>
